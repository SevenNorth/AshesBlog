---
title: 几种常见内存问题的解决策略
categories:
  - [v8]
copyright: true
date: 2022-04-20 06:59:37
tags: [v8]
---

## Node 中的 readFile API 工作机制

先通过两段代码来分析下同步和异步读文件 API 的区别。

```js
var fs = require('fs')
var data = fs.readFileSync('test.js')
```

```js
function fileHanlder(err, data){
  data.toString()  
}

fs.readFile('test.txt', fileHanlder)
```

<!-- more -->

Node 的体系架构可以参考下图：

![node的体系架构](https://raw.githubusercontent.com/SevenNorth/picGo/master/images/20220420071536.png)

Node 是 V8 的宿主，它会给 V8 提供事件循环和消息队列。在 Node 中，事件循环是由 libuv 提供的，libuv 工作在主线程中，它会从消息队列中取出事件，并在主线程上执行事件。

同样，对于一些主线程上不适合处理的事件，比如消耗时间过久的网络资源下载、文件读写、设备访问等，Node 会提供很多线程来处理这些事件，这些线程称为线程池。

通常，在 Node 中，会认为读写文件是一个非常耗时的工作，因此主线程会将回调函数和读文件的操作一道发送给文件读写线程，并让实际的读写操作运行在读写线程中。

比如当在 Node 的主线程上执行 readFile 的时候，主线程会将 readFile 的文件名称和回调函数，提交给文件读写线程来处理， 具体过程如下所示：

![提交IO线程处理](https://raw.githubusercontent.com/SevenNorth/picGo/master/images/20220420072217.png)

文件读写线程完成文件读取之后， 会将结果和回调函数封装成新的事件，并将其添加进消息队列中。比如文件读写线程将读取的文件内容放到内存中，并将data指针指向该内存，然后文件读写线程会将data和回调函数封装成新的事件，并将其丢进消息队列中，具体过程如下所示：

![封装新任务并添加到消息队列中](https://raw.githubusercontent.com/SevenNorth/picGo/master/images/20220420072658.png)

等到 libuv 从消息队列中读取该事件后，主线程就可以着手来处理该事件了。在主线程处理该事件的过程中，主线程调用事件中的回调函数，并将 data 结果数据作为参数，如下图所示：

![取出事件并处理](https://raw.githubusercontent.com/SevenNorth/picGo/master/images/20220420072930.png)

然后在回调函数中，就可以拿到读取的结果来实现一些业务逻辑了。

如果读取的文件体积不大或者项目瓶颈不在文件读写，那么依然使用异步调用和回调函数的模式就显得有点过度复杂了。

因此 Node 还提供了一套同步读写的 API。第一段代码中的 readFileSync 就是同步实现的，同步代码非常简单，当 libuv 读取到 readFileSync 的任务后，就直接在主线程上执行读写操作，等待读写结束，直接返回读写的结果，这也是同步回调的一种应用。当然在读写过程中，消息队列中的其他任务是无法被执行的。

所以在选择使用同步 API 还是异步 API 时，要看实际的场景，并不是非 A 即 B。几种内存问题